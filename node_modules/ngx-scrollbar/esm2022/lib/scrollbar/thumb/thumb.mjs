import { Output, Directive } from '@angular/core';
import { animationFrameScheduler, of, fromEvent, Subject } from 'rxjs';
import { distinctUntilChanged, map, mergeMap, pluck, takeUntil, tap } from 'rxjs/operators';
import { enableSelection, preventSelection, stopPropagation } from '../common';
import * as i0 from "@angular/core";
import * as i1 from "../../ng-scrollbar-base";
import * as i2 from "../track/track";
// @dynamic
export class ThumbAdapter {
    get trackMax() {
        return this.track.size - this.size;
    }
    // Get thumb client rect
    get clientRect() {
        return this.thumbElement.getBoundingClientRect();
    }
    // Stream that emits when scrollbar thumb is clicked
    get clicked() {
        return fromEvent(this.thumbElement, 'mousedown', { passive: true }).pipe(stopPropagation());
    }
    constructor(cmp, track, thumbElement, document) {
        this.cmp = cmp;
        this.track = track;
        this.thumbElement = thumbElement;
        this.document = document;
        // Stream that emits dragging state
        this._dragging = new Subject();
        this.dragging = this._dragging.pipe(distinctUntilChanged());
    }
    // Calculate and update thumb position and size
    update() {
        const size = calculateThumbSize(this.track.size, this.viewportScrollSize, this.cmp.minThumbSize);
        const position = calculateThumbPosition(this.viewportScrollOffset, this.viewportScrollMax, this.trackMax);
        animationFrameScheduler.schedule(() => this.updateStyles(this.handleDirection(position, this.trackMax), size));
    }
    /**
     * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged
     * This function is called by thumb drag event using viewport or scrollbar pointer events
     */
    dragged(event) {
        let trackMaxStart;
        let scrollMaxStart;
        const dragStart = of(event).pipe(preventSelection(this.document), tap(() => {
            // Capture scrollMax and trackMax once
            trackMaxStart = this.trackMax;
            scrollMaxStart = this.viewportScrollMax;
            this.setDragging(true);
        }));
        const dragging = fromEvent(this.document, 'mousemove', { capture: true, passive: true }).pipe(stopPropagation());
        const dragEnd = fromEvent(this.document, 'mouseup', { capture: true }).pipe(stopPropagation(), enableSelection(this.document), tap(() => this.setDragging(false)));
        return dragStart.pipe(pluck(this.pageProperty), map((pageOffset) => pageOffset - this.dragStartOffset), mergeMap((mouseDownOffset) => dragging.pipe(pluck(this.clientProperty), 
        // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).
        map((mouseOffset) => mouseOffset - this.track.offset), map((offset) => scrollMaxStart * (offset - mouseDownOffset) / trackMaxStart), map((position) => this.handleDrag(position, scrollMaxStart)), tap((position) => this.scrollTo(position)), takeUntil(dragEnd))));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: ThumbAdapter, deps: [{ token: i1.NgScrollbarBase }, { token: i2.TrackAdapter }, { token: HTMLElement }, { token: Document }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: ThumbAdapter, outputs: { dragging: "dragging" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: ThumbAdapter, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1.NgScrollbarBase }, { type: i2.TrackAdapter }, { type: HTMLElement }, { type: Document }]; }, propDecorators: { dragging: [{
                type: Output
            }] } });
/**
 * Calculate scrollbar thumb size
 */
function calculateThumbSize(trackSize, contentSize, minThumbSize) {
    const scrollbarRatio = trackSize / contentSize;
    const thumbSize = scrollbarRatio * trackSize;
    return Math.max(~~thumbSize, minThumbSize);
}
/**
 * Calculate scrollbar thumb position
 */
function calculateThumbPosition(scrollPosition, scrollMax, trackMax) {
    return scrollPosition * trackMax / scrollMax;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGh1bWIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtc2Nyb2xsYmFyL3NyYy9saWIvc2Nyb2xsYmFyL3RodW1iL3RodW1iLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xELE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxFQUFFLEVBQUUsU0FBUyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuRixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVGLE9BQU8sRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLE1BQU0sV0FBVyxDQUFDOzs7O0FBSS9FLFdBQVc7QUFFWCxNQUFNLE9BQWdCLFlBQVk7SUF1QmhDLElBQUksUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDLEtBQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztJQUN0QyxDQUFDO0lBRUQsd0JBQXdCO0lBQ3hCLElBQUksVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQ25ELENBQUM7SUFFRCxvREFBb0Q7SUFDcEQsSUFBSSxPQUFPO1FBQ1QsT0FBTyxTQUFTLENBQWEsSUFBSSxDQUFDLFlBQVksRUFBRSxXQUFXLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztJQUMxRyxDQUFDO0lBRUQsWUFBZ0MsR0FBb0IsRUFDcEIsS0FBbUIsRUFDbkIsWUFBeUIsRUFDekIsUUFBa0I7UUFIbEIsUUFBRyxHQUFILEdBQUcsQ0FBaUI7UUFDcEIsVUFBSyxHQUFMLEtB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QUMsRUFDcEUsR0FBRyxDQUFDLENBQUMsUUFBZ0IsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUNsRCxTQUFTLENBQUMsT0FBTyxDQUFDLENBQ25CLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQzs4R0F6Rm1CLFlBQVk7a0dBQVosWUFBWTs7MkZBQVosWUFBWTtrQkFEakMsU0FBUzs0S0FLRSxRQUFRO3NCQUFqQixNQUFNOztBQXVHVDs7R0FFRztBQUNILFNBQVMsa0JBQWtCLENBQUMsU0FBaUIsRUFBRSxXQUFtQixFQUFFLFlBQW9CO0lBQ3RGLE1BQU0sY0FBYyxHQUFHLFNBQVMsR0FBRyxXQUFXLENBQUM7SUFDL0MsTUFBTSxTQUFTLEdBQUcsY0FBYyxHQUFHLFNBQVMsQ0FBQztJQUM3QyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsQ0FBQztBQUM3QyxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLHNCQUFzQixDQUFDLGNBQXNCLEVBQUUsU0FBaUIsRUFBRSxRQUFnQjtJQUN6RixPQUFPLGNBQWMsR0FBRyxRQUFRLEdBQUcsU0FBUyxDQUFDO0FBQy9DLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPdXRwdXQsIERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBhbmltYXRpb25GcmFtZVNjaGVkdWxlciwgb2YsIGZyb21FdmVudCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwLCBtZXJnZU1hcCwgcGx1Y2ssIHRha2VVbnRpbCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBlbmFibGVTZWxlY3Rpb24sIHByZXZlbnRTZWxlY3Rpb24sIHN0b3BQcm9wYWdhdGlvbiB9IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IFRyYWNrQWRhcHRlciB9IGZyb20gJy4uL3RyYWNrL3RyYWNrJztcclxuaW1wb3J0IHsgTmdTY3JvbGxiYXJCYXNlIH0gZnJvbSAnLi4vLi4vbmctc2Nyb2xsYmFyLWJhc2UnO1xyXG5cclxuLy8gQGR5bmFtaWNcclxuQERpcmVjdGl2ZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUaHVtYkFkYXB0ZXIge1xyXG5cclxuICAvLyBTdHJlYW0gdGhhdCBlbWl0cyBkcmFnZ2luZyBzdGF0ZVxyXG4gIHByaXZhdGUgX2RyYWdnaW5nID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcclxuICBAT3V0cHV0KCkgZHJhZ2dpbmcgPSB0aGlzLl9kcmFnZ2luZy5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xyXG5cclxuICAvLyBSZXR1cm5zIGVpdGhlciAncGFnZVgnIG9yICdwYWdlWScgYWNjb3JkaW5nIHRvIHNjcm9sbGJhciBheGlzXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldCBwYWdlUHJvcGVydHkoKTogc3RyaW5nO1xyXG5cclxuICAvLyBSZXR1cm5zIGVpdGhlciAnY2xpZW50SGVpZ2h0JyBvciAnY2xpZW50V2lkdGgnIGFjY29yZGluZyB0byBzY3JvbGxiYXIgYXhpc1xyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBnZXQgY2xpZW50UHJvcGVydHkoKTogc3RyaW5nO1xyXG5cclxuICBhYnN0cmFjdCBnZXQgZHJhZ1N0YXJ0T2Zmc2V0KCk6IG51bWJlcjtcclxuXHJcbiAgLy8gUmV0dXJucyB0aHVtYiBzaXplLCBjbGllbnRIZWlnaHQgb3IgY2xpZW50V2lkdGhcclxuICBhYnN0cmFjdCBnZXQgc2l6ZSgpOiBudW1iZXI7XHJcblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBnZXQgdmlld3BvcnRTY3JvbGxTaXplKCk6IG51bWJlcjtcclxuXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldCB2aWV3cG9ydFNjcm9sbE9mZnNldCgpOiBudW1iZXI7XHJcblxyXG4gIGFic3RyYWN0IGdldCB2aWV3cG9ydFNjcm9sbE1heCgpOiBudW1iZXI7XHJcblxyXG4gIGdldCB0cmFja01heCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhY2shLnNpemUgLSB0aGlzLnNpemU7XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgdGh1bWIgY2xpZW50IHJlY3RcclxuICBnZXQgY2xpZW50UmVjdCgpOiBET01SZWN0IHtcclxuICAgIHJldHVybiB0aGlzLnRodW1iRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICB9XHJcblxyXG4gIC8vIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gc2Nyb2xsYmFyIHRodW1iIGlzIGNsaWNrZWRcclxuICBnZXQgY2xpY2tlZCgpOiBPYnNlcnZhYmxlPE1vdXNlRXZlbnQ+IHtcclxuICAgIHJldHVybiBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy50aHVtYkVsZW1lbnQsICdtb3VzZWRvd24nLCB7IHBhc3NpdmU6IHRydWUgfSkucGlwZShzdG9wUHJvcGFnYXRpb24oKSk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IocHJvdGVjdGVkIGNtcDogTmdTY3JvbGxiYXJCYXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgdHJhY2s6IFRyYWNrQWRhcHRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdGVjdGVkIHRodW1iRWxlbWVudDogSFRNTEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3RlY3RlZCBkb2N1bWVudDogRG9jdW1lbnQpIHtcclxuICB9XHJcblxyXG4gIC8vIENhbGN1bGF0ZSBhbmQgdXBkYXRlIHRodW1iIHBvc2l0aW9uIGFuZCBzaXplXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgY29uc3Qgc2l6ZSA9IGNhbGN1bGF0ZVRodW1iU2l6ZSh0aGlzLnRyYWNrIS5zaXplLCB0aGlzLnZpZXdwb3J0U2Nyb2xsU2l6ZSwgdGhpcy5jbXAubWluVGh1bWJTaXplISk7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IGNhbGN1bGF0ZVRodW1iUG9zaXRpb24odGhpcy52aWV3cG9ydFNjcm9sbE9mZnNldCwgdGhpcy52aWV3cG9ydFNjcm9sbE1heCwgdGhpcy50cmFja01heCk7XHJcbiAgICBhbmltYXRpb25GcmFtZVNjaGVkdWxlci5zY2hlZHVsZSgoKSA9PiB0aGlzLnVwZGF0ZVN0eWxlcyh0aGlzLmhhbmRsZURpcmVjdGlvbihwb3NpdGlvbiwgdGhpcy50cmFja01heCksIHNpemUpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0cmVhbSB0aGF0IGVtaXRzIHRoZSAnc2Nyb2xsVG8nIHBvc2l0aW9uIHdoZW4gYSBzY3JvbGxiYXIgdGh1bWIgZWxlbWVudCBpcyBkcmFnZ2VkXHJcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgdGh1bWIgZHJhZyBldmVudCB1c2luZyB2aWV3cG9ydCBvciBzY3JvbGxiYXIgcG9pbnRlciBldmVudHNcclxuICAgKi9cclxuICBkcmFnZ2VkKGV2ZW50OiBNb3VzZUV2ZW50KTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuICAgIGxldCB0cmFja01heFN0YXJ0OiBudW1iZXI7XHJcbiAgICBsZXQgc2Nyb2xsTWF4U3RhcnQ6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RhcnQgPSBvZjxNb3VzZUV2ZW50PihldmVudCkucGlwZShcclxuICAgICAgcHJldmVudFNlbGVjdGlvbih0aGlzLmRvY3VtZW50KSxcclxuICAgICAgdGFwKCgpID0+IHtcclxuICAgICAgICAvLyBDYXB0dXJlIHNjcm9sbE1heCBhbmQgdHJhY2tNYXggb25jZVxyXG4gICAgICAgIHRyYWNrTWF4U3RhcnQgPSB0aGlzLnRyYWNrTWF4O1xyXG4gICAgICAgIHNjcm9sbE1heFN0YXJ0ID0gdGhpcy52aWV3cG9ydFNjcm9sbE1heDtcclxuICAgICAgICB0aGlzLnNldERyYWdnaW5nKHRydWUpO1xyXG4gICAgICB9KSxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgZHJhZ2dpbmcgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy5kb2N1bWVudCwgJ21vdXNlbW92ZScsIHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHJ1ZSB9KS5waXBlKHN0b3BQcm9wYWdhdGlvbigpKTtcclxuXHJcbiAgICBjb25zdCBkcmFnRW5kID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KHRoaXMuZG9jdW1lbnQsICdtb3VzZXVwJywgeyBjYXB0dXJlOiB0cnVlIH0pLnBpcGUoXHJcbiAgICAgIHN0b3BQcm9wYWdhdGlvbigpLFxyXG4gICAgICBlbmFibGVTZWxlY3Rpb24odGhpcy5kb2N1bWVudCksXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLnNldERyYWdnaW5nKGZhbHNlKSlcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIGRyYWdTdGFydC5waXBlKFxyXG4gICAgICBwbHVjazxhbnksIHN0cmluZz4odGhpcy5wYWdlUHJvcGVydHkpLFxyXG4gICAgICBtYXAoKHBhZ2VPZmZzZXQ6IG51bWJlcikgPT4gcGFnZU9mZnNldCAtIHRoaXMuZHJhZ1N0YXJ0T2Zmc2V0KSxcclxuICAgICAgbWVyZ2VNYXAoKG1vdXNlRG93bk9mZnNldDogbnVtYmVyKSA9PiBkcmFnZ2luZy5waXBlKFxyXG4gICAgICAgIHBsdWNrKHRoaXMuY2xpZW50UHJvcGVydHkpLFxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBob3cgZmFyIHRoZSBwb2ludGVyIGlzIGZyb20gdGhlIHRvcC9sZWZ0IG9mIHRoZSBzY3JvbGxiYXIgKG1pbnVzIHRoZSBkcmFnT2Zmc2V0KS5cclxuICAgICAgICBtYXAoKG1vdXNlT2Zmc2V0OiBudW1iZXIpID0+IG1vdXNlT2Zmc2V0IC0gdGhpcy50cmFjayEub2Zmc2V0KSxcclxuICAgICAgICBtYXAoKG9mZnNldDogbnVtYmVyKSA9PiBzY3JvbGxNYXhTdGFydCAqIChvZmZzZXQgLSBtb3VzZURvd25PZmZzZXQpIC8gdHJhY2tNYXhTdGFydCksXHJcbiAgICAgICAgbWFwKChwb3NpdGlvbjogbnVtYmVyKSA9PiB0aGlzLmhhbmRsZURyYWcocG9zaXRpb24sIHNjcm9sbE1heFN0YXJ0KSksXHJcbiAgICAgICAgdGFwKChwb3NpdGlvbjogbnVtYmVyKSA9PiB0aGlzLnNjcm9sbFRvKHBvc2l0aW9uKSksXHJcbiAgICAgICAgdGFrZVVudGlsKGRyYWdFbmQpXHJcbiAgICAgICkpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gU2V0IGRyYWdnaW5nIHN0YXRlXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHNldERyYWdnaW5nKHZhbHVlOiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgLy8gU2Nyb2xsIHZpZXdwb3J0IGluc3RhbnRseVxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzY3JvbGxUbyhwb3NpdGlvbjogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgLy8gVXBkYXRlIHRodW1iIGVsZW1lbnQgc2l6ZSBhbmQgcG9zaXRpb25cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgdXBkYXRlU3R5bGVzKHBvc2l0aW9uOiBudW1iZXIsIHNpemU6IG51bWJlcik6IHZvaWQ7XHJcblxyXG4gIC8vIEhhbmRsZSBkcmFnZ2luZyBwb3NpdGlvbiAoU3VwcG9ydCBMVFIgYW5kIFJUTCBkaXJlY3Rpb25zIGZvciB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIpXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGhhbmRsZURyYWcocG9zaXRpb246IG51bWJlciwgc2Nyb2xsTWF4PzogbnVtYmVyKTogbnVtYmVyO1xyXG5cclxuICAvLyBIYW5kbGUgc2Nyb2xsaW5nIHBvc2l0aW9uIChTdXBwb3J0IExUUiBhbmQgUlRMIGRpcmVjdGlvbnMgZm9yIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhcilcclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgaGFuZGxlRGlyZWN0aW9uKHBvc2l0aW9uOiBudW1iZXIsIHNjcm9sbE1heD86IG51bWJlcik6IG51bWJlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBzY3JvbGxiYXIgdGh1bWIgc2l6ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlVGh1bWJTaXplKHRyYWNrU2l6ZTogbnVtYmVyLCBjb250ZW50U2l6ZTogbnVtYmVyLCBtaW5UaHVtYlNpemU6IG51bWJlcik6IG51bWJlciB7XHJcbiAgY29uc3Qgc2Nyb2xsYmFyUmF0aW8gPSB0cmFja1NpemUgLyBjb250ZW50U2l6ZTtcclxuICBjb25zdCB0aHVtYlNpemUgPSBzY3JvbGxiYXJSYXRpbyAqIHRyYWNrU2l6ZTtcclxuICByZXR1cm4gTWF0aC5tYXgofn50aHVtYlNpemUsIG1pblRodW1iU2l6ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgc2Nyb2xsYmFyIHRodW1iIHBvc2l0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVUaHVtYlBvc2l0aW9uKHNjcm9sbFBvc2l0aW9uOiBudW1iZXIsIHNjcm9sbE1heDogbnVtYmVyLCB0cmFja01heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICByZXR1cm4gc2Nyb2xsUG9zaXRpb24gKiB0cmFja01heCAvIHNjcm9sbE1heDtcclxufVxyXG4iXX0=